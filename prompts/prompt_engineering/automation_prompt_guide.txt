## Automation Prompt Engineering Guide

### PURPOSE
This guide documents how to create systematic, reproducible prompts for AI-human collaboration workflows. Based on real implementation experience building structured development processes.

### KEY AUTOMATION PATTERNS

#### 1. INQUIRY-BEFORE-ACTION PATTERN
**User Request**: "I want AI to always ask clarifying questions before coding"
**Generated Automation**: JSON command system with analysis file references
**Keywords**: "always ask", "before coding", "clarifying questions", "structured approach"

#### 2. PERSISTENT KNOWLEDGE PATTERN  
**User Request**: "I don't want to repeat the same explanations every time"
**Generated Automation**: Analysis log files with context references
**Keywords**: "don't repeat", "remember decisions", "build knowledge", "reference previous"

#### 3. STANDARDIZED OUTPUT PATTERN
**User Request**: "I want consistent commit messages and file organization"
**Generated Automation**: Template-based formatting with validation
**Keywords**: "consistent", "standardized", "template", "format"

#### 4. PROGRESSIVE LEARNING PATTERN
**User Request**: "I want to learn while building, not just get results"
**Generated Automation**: Step-by-step protocols with explanation requirements
**Keywords**: "learn while building", "understand why", "explain options", "educational"

### REPRODUCIBLE PROMPT STRUCTURE

#### Core Components:
1. **load_context_files**: ["principle.llm.txt", "relevant_analysis.txt"]
2. **protocol_context**: ["behavior_rules.llm.txt"]
3. **requirements**: {structure, code_style, execution}
4. **evaluation_criteria**: ["measurable outcomes"]
5. **analysis_reference**: "prompts/log/topic_analysis_latest.txt"

#### Automation Keywords for Reusability:
- **"always"** → Behavior rule in protocol file
- **"systematic"** → Step-by-step process definition
- **"remember"** → Context file references
- **"consistent"** → Template/format specification
- **"before"** → Pre-action protocol requirement
- **"track"** → Progress monitoring system
- **"reusable"** → Modular component design

### REQUEST-TO-AUTOMATION MAPPING

#### If User Says: "I want AI to understand project context automatically"
**Create**: 
- principle.llm.txt with project overview
- Auto-loading context system in JSON commands
- File organization standards

#### If User Says: "I want systematic questioning before every task"
**Create**:
- question_loop.llm.txt with inquiry protocol
- Analysis log system in prompts/log/
- Reference system in JSON commands

#### If User Says: "I want to build knowledge over time, not start fresh"
**Create**:
- Persistent analysis files
- Context accumulation system
- Conflict detection mechanism

#### If User Says: "I want standardized development workflow"
**Create**:
- Commit message templates
- Component classification system
- Progress tracking standards

### ESSENTIAL PROMPT ENGINEERING PRINCIPLES

#### 1. SEPARATION OF CONCERNS
- Context files (what)
- Protocol files (how)  
- Analysis files (why/decisions)
- Command files (execute)

#### 2. INCREMENTAL SPECIFICITY
- Start with broad requirements
- Add specific constraints through experience
- Document edge cases and decisions

#### 3. FEEDBACK LOOPS
- Analysis → Decision → Implementation → Review → Update Analysis
- Each cycle improves the system

#### 4. COMPOSABILITY
- Small, reusable components
- Mix and match for different scenarios
- Clear interfaces between components

### WARNING SIGNS OF BAD AUTOMATION
- Too rigid (no flexibility for edge cases)
- Too complex (users avoid the system)
- Too generic (doesn't capture domain specifics)
- No feedback mechanism (can't improve over time)

### SUCCESS INDICATORS
- Reduced repetitive explanations
- Faster task completion after initial setup
- Accumulated project knowledge
- Consistent output quality
- Easy onboarding for new team members

### IMPLEMENTATION CHECKLIST
1. Identify repetitive interaction patterns
2. Extract reusable components
3. Create context/protocol files
4. Design JSON command structure
5. Implement analysis/logging system
6. Test with real scenarios
7. Iterate based on usage