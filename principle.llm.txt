## project_goal
Build a real-time, API-driven anomaly detection system for supply chain barcodes.
Detect forged EPCs, logistical errors, and impossible travel times using both rule-based logic and machine learning.

## Environment
- OS: Windows
- Language: Python
- Framework: FastAPI

### Main Libraries and Versions
- numpy==2.3.0
- pandas==2.3.0
- scikit-learn==1.6.1
- torch==2.7.1+cu118
- torchvision==0.22.1+cu118
- torchaudio==2.7.1+cu118
- matplotlib==3.10.3
- seaborn==0.13.2

### How to Use
- All development and execution are done inside a Conda virtual environment named `ds`.
- Before running any code, activate the environment:conda activate ds


### Notes
- This environment is optimized for data analysis, machine learning, deep learning, visualization, and API development.
- CUDA support is enabled for torch, torchvision, and torchaudio.
- Using a virtual environment (conda/venv) is strongly recommended for package isolation and reproducibility.



## key_files
- /src/barcode/api.py: FastAPI core (entry point for the API).
- /src/barcode/anomaly_detection_v5.py: Rule-based anomaly detection logic.
- /src/barcode/anomaly_detection_combined.py: Combines multiple anomaly detection models.
- /src/barcode/anomaly_detection_decomposed.py: Decomposes anomaly detection into smaller, manageable functions.
- /src/barcode/anomaly_detection_verifier.py: Verifies the output of the anomaly detection models.
- /src/barcode/transition_time_analyzer_v2.py: Analyzes travel-time anomalies ("jump" errors).
- /data/: Contains raw, processed, and external datasets.
- /docs/: Project documentation and research notes.
- requirements.txt: Python package dependencies.

## data_schema
- scan_location (string): Human-readable location where the EPC was scanned (e.g., '화성공장').
- location_id (integer): Numerical ID for each location.
- hub_type (string): Facility type (e.g., 'HWS_Factory', 'SEL_Logi_HUB_Inbound').
- business_step (string): Stage in supply chain (e.g., 'Factory', 'WMS', 'Logistics_HUB', etc.).
- event_type (string): Action that occurred at that location (e.g., 'Aggregation', 'HUB_Outbound').
- epc_code (string): EPC identifier. Composed of:
  - epc_header (string): Always '001'.
  - epc_company (string): 7-digit company code.
  - epc_product (string): 7-digit product code.
  - epc_lot (string): 6-digit lot code.
  - epc_manufacture (string): 8-digit manufacture date (YYYYMMDD).
  - epc_serial (string): 9_fil-digit unique serial.
- product_name (string): Human-readable product name.
- event_time (datetime): When the scan happened.
- manufacture_date (datetime): Product manufacture timestamp.
- expiry_date (datetime): Product expiry timestamp.
- factory (string): Factory of origin (e.g., 'hws', 'icn').

## anomaly_types
- epcFake: Malformed EPC code (structure-level error).
- epcDup: Same EPC scanned at different locations at the exact same time.
- locErr: Invalid location sequence in supply chain (e.g., backward movement).
- evtOrderErr: Events out of logical order within the same location.
- jump: Travel time between two events is statistically impossible.
- svm_outlier: Statistically detected anomaly using One-Class SVM (not caught by rules).

## ai_guidelines

- Versioning: Use new files for major feature versions (e.g., *_v2.py).
- Coding style: Write reproducible and clear code. Focus comments on the “why”, not the “what”.
- Prefer clarity and education over cleverness. Code should be easy to understand, even if longer.
- Use GPU acceleration if beneficial (e.g., for ML models or heavy computation).
- Apply test-driven approach: After a function or file is completed, write a test and commit immediately.
- Keep each AI interaction small and focused:
  - Max 1 file change per interaction
  - Max 2–3 new functions
  - Max 10 lines per function

## prompt_preferences

- Always ask where the new code should be inserted and explain the reason for that choice.
- Provide 2–3 implementation options when possible, each with pros and cons to help the user learn.
- Assume the user is a learner aiming to understand the codebase like a product manager.
- Use “plan mode” when coding, guiding the user with small, clear steps.
- Help the user rollback safely and commit confidently after successful changes.
- Always show the full code explicitly. Do not summarize or omit essential parts.

## ai_interaction_protocol

1. Summarize the user’s motivation and goal.
2. Identify and highlight any ambiguity in the instruction.
3. Restate your understanding of the task using a numbered summary.
4. Propose 3 possible implementation strategies with brief pros/cons.
5. Compare the request with similar previous tasks or concepts, and explain the difference.
6. Anticipate edge cases and describe how your code handles them.
7. Visualize the solution:
   - Include a minimal working code snippet
   - Provide a flowchart if possible (ASCII/text-based OK)
   - Show table/column structures if working with DataFrames
8. Continuously summarize progress using steps like “So far, we’ve done A → B → C”
9. Suggest how this knowledge or logic can be applied elsewhere.
10. Suggest 3 ways the user could ask even better questions next time.
11. Reflect on hidden assumptions in the user’s instruction.
12. If the user seems unsure (“maybe”, “I think…”), ask clarifying questions before answering.

